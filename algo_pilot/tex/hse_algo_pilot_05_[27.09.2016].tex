\documentclass[a4paper, 12pt]{article}
\usepackage{header}

\begin{document}
\pagestyle{fancy}

\section{Лекция 5 от 27.09.2016. RSA, продолжение некоторых теоретико числовых
алгоритмов, некоторые комбинаторные оптимизации}
\epigraph{<<На самом деле, если этот алгоритм (разложение на простые) 
придумают за полиномиальное время, можно спокойно идти и покупать
попкорн и смотреть, как рушится этот мир.
\\
Только не забудьте перед этим снять все деньги с банковских карточек.>>}
{Глеб}

\textit{Прим. Я в этой лекции поменял местами темы, чтобы было легче воспринимать
материал.}

\subsection{Предисловие}

Теория чисел с появлением алгоритмов, а особенно криптографии, приобрела новую 
<<жизнь>>. Теперь простые числа, разложение на простые множители являются
важными алгоритмами даже в нашей повседневной жизни. Сначала поговорим о самих
простых числах, потом о криптографии.

\subsection{Тест Рабина-Миллера на проверку простоты числа}

В той же самое криптографии есть необходимость в генерировании длинных простых
чисел. Благо простые числа встречаются не так редко. Пусть
функция распределения простых чисел будет $\pi(n)$ --- количество
чисел, не б\'{о}льших $n$, которые являются простыми. Есть теорема, о которой
мы уже упоминали

\[
  \lim\limits_{n \to +\infty} \frac{\pi(n)}{n/\ln(n)} = 1
\]

То есть если взять случайно $\ln(n)$ чисел до $n$, то математическое ожидание, что
хотя бы одно из них будет простым равно 1.

Поэтому, чтобы сгенерировать большое простое число, надо уметь проверять за
полином от числа (было бы вообще прекрасно), является ли число простым. Был
найден алгоритм, который проверяет это свойство за полином от размера числа.

Но мы рассмотрим достаточно эффективный вероятностный алгоритм проверки числа
на простоту. Вспомним малую теорему Ферма, которая нам гласит:

\[
  a^{p - 1} \equiv 1 \Mod p \text{ для всех простых чисел $p$}.
\]

\begin{Def}
  Назовём число $n$ \textit{псевдопростым} по основанию $a$, если $(a, n) = 1$ и 
  $a^{n - 1} \equiv 1 \pmod n$.
\end{Def}

Поэтому первый наш алгоритм будет такой (будем проверять нечётные $n$ и $a = 2$):

\begin{algorithm}
  \caption{Проверка на псевдопростоту по основанию $2$.}
  \begin{algorithmic}[1]
    \Function{Pseudoprime}{int $n$} 
      \If{FAST\_POW(2, $n - 1$, $n) \neq 1$}
        \State return Составное \Comment{100\% составное}
      \EndIf
      \State return Простое \Comment{молимся и надеемся, что тут действительно простое}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Но, к сожалению, существуют и составные числа, которые удовлетворяют этому 
алгоритму
и нам выведется, что число простое, а на самом деле нет. Наименьшие из них это
$341, 561 \ldots$ и так далее. Поменять основание тоже не вариант, так как
существуют числа Карлмайка, которые псевдопростые по любому основанию.
Но было доказано, что с ростом $n$ вероятность,
что непростое число является псевдопростым стремится к 0.

К \sout{счастью} сожалению, мы не будем доказывать вероятность ошибки этого
алгоритма (она составляет не более 0.5), поэтому если запустить этот алгоритм
$k$ раз, то вероятность ошибки будет равна $2^{-k}$. Собственно, алгоритм:

\begin{algorithm}
  \caption{Тест Миллера-Рабина, считаем, что $n - 1 = 2^t u$, где $u$ нечетно и 
  $t \geqslant 1$}
  \begin{algorithmic}[1]
    \Function{MILLER\_RABIN}{int $n$}
      \Let{$a$}{random\_integer$(1, n - 1)$}
      \Let{$x_0$}{FAST\_POW$(a, u, n)$}
      \For{$i \gets 1 \textbf{ to } t$}
        \Let{$x_i$}{$x_{i - 1}^2 \Mod n$}
        \If{$x_i = 1$ и $x_{i - 1} \neq 1$ и $x_{i - 1} \neq n - 1$}
          \State return Составное
        \EndIf
      \EndFor
    \If{$x_t \neq 1$}
      \State return Составное
    \EndIf
    \State return Простое
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{Lemma}
  Если алгоритм как-то вышел на строчки 7 или 9, то число действительно 
  составное.
\end{Lemma}

\begin{proof}
  Заметим, что $x_i \equiv a^{2^i u} \Mod n$, так как $x_0 \equiv a^{u} \Mod n$
  (база индукции) и 
  $x_i = x_{i - 1}^2 \Mod n$ (переход индукции), а значит $x_i \equiv a^{2^{i -
  1} u} \cdot
  a^{2^{i - 1} u} \equiv a^{2^{i} u} \Mod n$. 

  Поэтому если $x_i = 1$ и $x_{i - 1} \neq 1$ и $x_{i - 1} \neq n - 1$, то 
  $n \ | \ x_{i - 1}^2 - 1$, то есть $(x_{i - 1} - 1)(x_{i - 1} + 1) = 0$ в 
  $\Z_n$.
  То есть у нас нетривиальные делители нуля, а из курса алгебры известно, что в
  поле (а при простых $n$ --- $\Z_n$ поле) их нет, поэтому перед нами составное 
  число.

  Если $x_t \neq 1$, то просто-напросто не выполняется малая теорема Ферма и 
  тогда $n$ точно составное.
\end{proof}

\begin{Lemma}
Количество таких $a$, 
на которых алгоритм выдаст <<Составное>> не меньше $\frac{n - 1}{2}$ при
составном нечетном $n$.
\end{Lemma}

Именно этот факт мы оставим без доказательства ({\it Прим. на самом деле, он не очень
сложный, видимо, Глебу было лень}).
И именно он нам даёт ошибку не более 0.5.

\subsection{RSA, криптография}

Криптографическую систему с открытым ключом можно использовать для шифровки
сообщений, которыми обмениваются 2 партнера (Алиса и Боб), чтобы посторонние
люди (Ева в дальнейшем), даже перехватившие сообщения,
не могли его расшифровать. Также некоторая система позволяет подписывать 
свои подписи. Кто угодно без труда может её проверить, но подделать никак.

Давайте уже перейдём к обсуждению различных систем.

Но для начала несколько определений. У Алисы есть 
ключи $P_{A}, R_{A}$, у Боба $P_{B}, R_{B}$ --- 
публичные и приватные соответственно (на самом деле это функции, которые 
что-то вычисляют). Алиса и Боб хранят приватные ключи у себя,
а с открытыми можно делать что угодно. Будем считать, что Алиса и Боб передают
двоичные последовательности. Также будем считать, что $M = P_{A}(R_{A}(M)) = R_{
A}(P_{A}(M))$ и $M = P_{B}(R_{B}(M)) = R_{B}(P_{B}(M))$. Также, чтобы шифрование
имело смысл, надо, чтобы секретные ключи владельцы умели вычислять быстро, и
чтобы по открытому ключу было очень сложно вычислить обратное преобразование.
На этом и держится весь алгоритм. Рассмотрим пример:

\begin{center}
  Боб хочет отправить сообщение $M$ Алисе, зашифрованное так, чтобы для Евы оно
  выглядело как ужасный набор символов:
  \begin{itemize}
    \item Боб получает открытый ключ Алисы $P_{A}$ любым способом;
    \item Боб шифрует сообщение, которое знает только он, как $C = P_{A}(M)$;
    \item Алиса, когда получает сообщение $C$, расшифровывает своё сообщение с
    помощью секретного ключа.
  \end{itemize}
\end{center}

Функции обратные, поэтому вычисления будут корректными. Но, к сожалению, такая система
плоха тем, что, перехватив сообщения, Ева может их подменивать. Поэтому
часто используют ещё и цифровые подписи:

\begin{center}
Пусть Алиса хочет отправить сообщение $M'$ Бобу:
  \begin{itemize}
    \item Алиса вычисляет свою подпись с помощью своего секретного ключа.
    $\sigma = R_{A}(M')$;
    \item Алиса отправляет пару Бобу $(M', \sigma)$;
    \item Боб может легко убедиться, что это действительно Алиса, с помощью
    открытого ключа, вычислив $P_{A}(\sigma)$ и сравнив с $M'$.
  \end{itemize}
\end{center}

В данном случае никакая Ева не страшна в подмене сообщения, так как она не может
вычислить $S_{A}(M')$ ни для какого $M'$.

Такие подписи позволяют проверять целостность сообщений. Но всё равно есть
проблема --- Ева знает содержания сообщений. Можно взять ещё 1 ключ, который
шифрует по 1-ой схеме сообщения, которые мы передаём по 2-ой схеме. И тогда
Ева, даже получив перехваченное сообщение, во-первых, не сможет понять, какой
парой оно было зашифровано, то есть дешифровка невозможна за разумное время,
да и подмена тоже, так как там применяется к сообщению сложный ключ.

Проблема остаётся одна --- что Алиса и Боб должны обменяться ключами, чтобы
Ева не могла подменить открытые ключи. Но, к сожалению, невозможно спрятаться
от Евы, если быть совсем параноиком. Она всегда может подменять вам ключи, где
бы вы ни находились. Поэтому фактор личной встречи должен быть. И самая большая
<<insecurity>> находится именно в том, что Ева внедряется работать к Алисе,
чтобы разузнать, а то и подменять ключи для Боба.

Давайте уже, наконец-то поговорим о способах шифрования:

\begin{itemize}
  \item Самая старая система это шифр Цезаря. Она просто переставляет по циклу
  символы в алфавите, что конечно, же ломается за $O(k)$, где $k$ --- размер
  алфавита
  \item Взять рандомную перестановку алфавита. Да, задача уже сложнее, но
  если это какой-нибудь язык, то можно из статистических параметров
  восстанавливать символы, что значительно сократит перебор. Не годится.
  \item Например, выравнивать двоичные сообщения и брать рандомную перестановку,
  применяя её ко всем сообщениям. Тогда нетрудно убедиться, что за $O(\log n)$
  действий мы сможем понять, какой символ, где стоит. Просто смотреть, куда
  переходят единицы и нули. На непонятных рандомных сообщениях математическое
  ожидание того, чтобы разобрать, где что стоит, будет $O(\log n)$.
\end{itemize}

Все примеры сверху так или иначе зависят от человеческого фактора или
для них легко подобрать обратную функцию. Рассмотрим криптографическую систему
RSA (Rivest--Shamir--Adleman public-key cryptosystem).

\begin{itemize}
  \item[1.] Случайным образом выбираются 2 больших простых числа $p \neq q$. Мы
  уже обсудили выше, что это сделать легко достаточно.
  \item[2.] Вычисляется $n = pq$ (что можно сделать тоже не очень сложно
  алгоритмом Карацубы или преобразованием Фурье).
  \item[3.] Выбирается маленькое нечетное число $e$, взаимно простое с 
  $\varphi(n) = (p - 1)(q - 1)$ из-за мультипликативности.
  \item[4.] Вычисляем число $d = e^{-1} \Mod \varphi(n)$. Это можно сделать
  расширенным алгоритмом Евклида.
  \item[5.] Пара $P = (e, n)$ будет открытым ключом.
  \item[6.] Пара $S = (d, n)$ закрытым.
\end{itemize}

Теперь в качестве сообщения мы передаём сообщение $P(M) = M^{e} \Mod n$.

Обратное шифрование будет равно $S(C) = C^{d} \Mod n$.

\begin{Lemma}[Корректность RSA]
  Докажем, что это взаимно обратные функции.
\end{Lemma}
\begin{proof}
  Видно, что $P(S(M)) = S(P(M)) = M^{ed} \Mod n$.

  Так как $e, d$ взаимно обратные по модулю $\varphi(n)$, то $ed = 1 + k(p - 1)(q - 1)$

  \[
    M^{ed} \equiv M^{1 + k(p - 1)(q - 1)} \equiv M \cdot M^{k(q - 1)\varphi(p)}
    \Mod p
  \]

  \[
    M^{ed} \equiv M^{1 + k(p - 1)(q - 1)} \equiv M \cdot M^{k(p - 1)\varphi(q)}
    \Mod q
  \]

  Малая теорема Ферма имеет очень простое следствие, что для любых чисел 
  $M^{p} \equiv M \Mod p$ (предлагается это доказать самостоятельно).
  Поэтому в обоих равенствах в арифметике это просто эквивалентно $M$, то есть

  \[
    M^{ed} \equiv M \Mod p \text{ и } M^{ed} \equiv M \Mod q
  \]

  А значит по легкому следствию из основной теоремы арифметики
  $M^{ed} \equiv M \Mod n$.
\end{proof}

Основная сложность в том, что зная $n, e, M^{e} \Mod n$ практически невозможно
найти $M$. Перебрать все $M$ может занять экспоненциальную сложность, а
разложение на множители $n$ и вычисление $d$ 
оказалось очень сложной задачей, которая пока не решается за полиномиальное
время.

{\bf Байка от Глебаса:}
  На самом деле вся теория по шифрованию в интернете появилась лет 5-6 назад.
  Раньше кто угодно мог перехватывать сообщения вашей почты, платить в интернете
  было опасно (если вообще можно было).
  Я только однажды покупал что-то не через безопасное соединение
  в интернете. Я очень хотел ту пиццу, мне было без разницы тогда на 
  безопасность.


\subsection{Комбинаторные оптимизации. Генетический алгоритм}

{\it На этой лекции был треш. Я честно не знаю, как это конспектировать. Напишу
то, в чём я разобрался.}

На лекции были рассмотрены метод Ньютона, отжига и генетический алгоритм. Всегда
есть Google, поэтому первые 2 ищите там. 

Генетический алгоритм позволяет решать некоторые трудные задачи методом ошибок
за разумное время.

Есть несколько фаз алгоритма:

\begin{itemize}
  \item {\bf Создание популяции.} Обычно это какие-то рандомные решение нашей 
  задачи, которые могут иметь много ошибок.
  \item {\bf Размножение.} Тут всё как у людей. Мы скрещиваем некоторые особи (
  обычно сильные особи) вместе, чтобы получить лучшее поколение.
  \item {\bf Мутация.} Тут природа говорит, что мутации иногда хорошо влияют
  на организмы. Мы просто берем некоторые особи и мутируем их с помощью
  какого-то заранее определенного алгоритма. Да, могут получиться плохие
  особи, но есть вероятность, что получаться хорошие.
  \item {\bf Отбор.} Мы отбираем самых лучших, те, кто пойдут дальше повторять
  этот процесс.
\end{itemize}

Иногда такой алгоритм приносит правильные решения. 

{\it Далее материала не было на лекции.}

Приведём пример работы генетического алгоритма в задаче о правильной
расстановке ферзей.

Берем какую-нибудь перестановку, что в строках и столбцах ровно по 1 ферзю.
Генерируем, например, 100 таких перестановок.

Потом считаем количество ошибок, то есть количество пар, которые бьют друг
друга (это можно сделать за $O(n)$, пройдясь по диагоналям).

После этого выбираем хороших особей --- примерно половину, у которых ошибок
меньше всего. Берем любые 2, смотрим, какие элементы у них совпадают, оставляем
их в предположении, что они являются <<сильными>> генами, а остальное всё
перемешиваем между собой. Так делаем с каким-то количеством пар, потом
выбираем, например, 1 особь, мутируем её --- меняем 2 любых элемента местами.

Опять же считаем количество ошибок и выбираем лучших 100. Повторяем алгоритм,
пока не найдём нужное решение.

Генетический алгоритм ничего не доказывает, он лишь может работать как природа.
Мы можем находить какие-то хорошие решение с его помощью за более разумное время.

 {\bf Байка от Глебаса:}
  В конце 40-ых годов появилась компания RAND, которая одна из первых вообще
  придумала работать со случайными числами ({\it Прим. и даже сгенерировала 
  огромный список случайных цифр}). Вообще, это была первая компания, которая
  моделировала процессы с помощью случайных чисел.


\end{document}
